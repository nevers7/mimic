---
title: "conrad_mimic"
author: "Bailey Conrad"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(ggplot2)
library(coin)
library(rstatix)
library(glmm)
library(broom)
library(rlist)
library(ggtext)
library(glue)
library(ggrepel)

?ggtext
```

```{r}
#row.names = 1 : row names are in column 1 in data set
king <- read.csv("/Users/baileyconrad/Desktop/bewell/data/derived/RelAbun/RelAbun_king.csv", row.names = 1)
phyl <- read.csv("/Users/baileyconrad/Desktop/bewell/data/derived/RelAbun/RelAbun_phyl.csv",row.names = 1)
class <- read.csv("/Users/baileyconrad/Desktop/bewell/data/derived/RelAbun/RelAbun_class.csv",row.names = 1)
ord <- read.csv("/Users/baileyconrad/Desktop/bewell/data/derived/RelAbun/RelAbun_ord.csv", row.names = 1)
fam <- read.csv("/Users/baileyconrad/Desktop/bewell/data/derived/RelAbun/RelAbun_fam.csv", row.names = 1)
gen <- read.csv("/Users/baileyconrad/Desktop/bewell/data/derived/RelAbun/RelAbun_gen.csv", row.names = 1)
spec <- read.csv("/Users/baileyconrad/Desktop/bewell/data/derived/RelAbun/RelAbun_spec.csv", row.names = 1)
```

```{r}
capture.models.univ <- function(outcome, lfun, mics, modin){
  mods.list <- lapply(mics, function(x)  try({glm(as.formula(paste0(outcome, " ~ ", x)), family = lfun, data = modin) %>% tidy()}))
  #glm: generalized linear model
                      
  mods.list.clean <- list.clean(mods.list, function(x) is.null(x))
  mods.df <- bind_rows(mods.list.clean)
  return(mods.df)
}
#list.clean: removes all elements that are TRUE
#is.null function: to remove missing values

format_and_model <- function(tmp){
 tmp.mics <- colnames(tmp)
tmp.form <- tmp %>%
  rownames_to_column(var = "sample") %>%
  mutate(berry.group = ifelse(grepl("tB",sample), 1, 0)) #ifelse: TRUE if 1, FLASE if 0
#grepl: check somethign by comparing it across a pattern (pattern, vaeiable)
res <- capture.models.univ("berry.group", "binomial", tmp.mics, tmp.form) %>%
  filter(term !="(Intercept)")
return(res)
}
```

```{r warning=FALSE}
all_tax_levs <- list(king, phyl, class, ord, fam, gen, spec)
all_mod_res <- lapply(all_tax_levs, format_and_model) %>%
  bind_rows() %>%
  arrange(p.value)
#arrange(asc) vs. desc
```

```{r}
all_mod_res %>%
  filter(p.value<0.1) %>%
  separate(term, into = c("TaxaLevel", "term"), sep = "__") %>%
  mutate(term = gsub("_", " ", term), # gsub: replacing the " " with the "_" in the term axis # mutate creates new variables
         term = fct_reorder(term, estimate)
         ) %>%
ggplot(aes(x = estimate, y = term, fill = TaxaLevel)) +
  geom_col() +
  labs(x = "Effect Size", y = "Microbe") +
  scale_fill_manual(breaks = c("g", "s"), values = c("firebrick", "grey70"), name = "Taxa level", labels = c("Genus", "Species")) +
  theme_bw() 
ggsave("../figures/effect-size_logistical-regression.png")
```

```{r warning=FALSE}
all_mod_res %>%
  separate(term, into = c("TaxaLevel", "term"), sep = "__") %>%
  mutate(pointlabs = ifelse(p.value < 0.1, term, NA)) %>%
  mutate(pointlabs = gsub("_", " ", pointlabs)) %>%
ggplot(aes(x = estimate, y = -log(p.value), label = pointlabs, color = TaxaLevel)) +
  xlim(-500,500) +
  ylim(0, 5) +
  geom_point() +
  theme_bw() +
  labs(x = "Estimate", y = "-log(p-value)") +
  geom_hline(yintercept = 2.0)+
  scale_x_log10() +
  geom_label_repel(show.legend = F)


ggsave("../figures/effect-size_volcano-plot.png")
```


function to run wilcox test on pre/post BRB and return table of p-values
```{r}
run_wilcox <- function(level, str1, str2){
  #level, str1: string 1; str2: string 2 
  #arguments: the parameters needed for the function to perform operations
  microbes <- colnames(level)
  #colnames: microbes
  tableOfResults<-data.frame(var=microbes)
  tableOfResults$p_wilcox <- NA
  tableOfResults$effect_size <- NA
  rownames(tableOfResults) <- microbes

  tempR <- filter(level, grepl(str1, rownames(level)))
  tempT <- filter(level, grepl(str2, rownames(level)))
  #grepl: searches for matches to argument pattern 
  #level: x

  for(mic in colnames(level)){
  #mic: maximal information coefficient
    x <- tempR[, mic]
    y <- tempT[, mic]
    x.df <- as.data.frame(x) %>%
  #as.data.frame is used to coerce other object to a data frame, not create a new one
    rename("rB" = x)
  #x = "rB" (pre-berry)
  y.df <- as.data.frame(y) %>%
    rename("tB" = y)
  #y = "tB" (post-berry)
  temp <- cbind(x.df, y.df)
  # cbind ("column-bind"): combines data frames by columns 
  temp$id <- rownames(temp)
  #$ (extraction operator): view a single vairable in data frame--only the id
  temp <- temp %>%
    gather(key = "group", value = "relAbun", rB, tB)
  #gather: to gather a key-value pair across multiple columns
  #key = name of the key column to create ("group")
  #value = name of the value column to create ("relAbun")
    thiscommand <- paste("thiswilcox <- wilcox.test(x, y, paired = TRUE)")
    eval(parse(text = thiscommand))
    tableOfResults[mic, "p_wilcox"] <- thiswilcox$p.value#p value graph
  #paste: multiple elements from the multiple vectors into one element
  #running the wilcox test--looking at y(post berry) - x(pre berry) 
  #parse: to return the parsed but unevaluated expression (text (this command) to be parsed)
    thiscommand <- paste("thiswilcox <- temp %>% wilcox_effsize(relAbun ~ group, paired = TRUE)")
    eval(parse(text = thiscommand))
    tableOfResults[mic, "effect_size"] <- thiswilcox$effsize
  #effect size calculation
}
  tableOfResults <- tableOfResults %>% select(p_wilcox, effect_size)
  #only selecting the p value function and effect size
  return(tableOfResults)
}
```

```{r}
level <- spec
str1 <- "rB"
str2 <- "tB"



run_wilcox <- function(level, str1, str2){
  #level, str1: string 1; str2: string 2 
  #arguments: the parameters needed for the function to perform operations
  microbes <- colnames(level)
  #colnames: microbes
  tableOfResults<-data.frame(var=microbes)
  tableOfResults$p_wilcox <- NA
  tableOfResults$effect_size <- NA
  rownames(tableOfResults) <- microbes

  tempR <- filter(level, grepl(str1, rownames(level)))
  tempT <- filter(level, grepl(str2, rownames(level)))
  #grepl: searches for matches to argument pattern 
  #level: x

  for(mic in colnames(level)){
  #mic: maximal information coefficient
    x <- tempR[, mic]
    y <- tempT[, mic]
    x.df <- as.data.frame(x) %>%
  #as.data.frame is used to coerce other object to a data frame, not create a new one
    rename("rB" = x)
  #x = "rB" (pre-berry)
  y.df <- as.data.frame(y) %>%
    rename("tB" = y)
  #y = "tB" (post-berry)
  temp <- cbind(x.df, y.df)
  # cbind ("column-bind"): combines data frames by columns 
  temp$id <- rownames(temp)
  #$ (extraction operator): view a single vairable in data frame--only the id
  temp <- temp %>%
    gather(key = "group", value = "relAbun", rB, tB)
  #gather: to gather a key-value pair across multiple columns
  #key = name of the key column to create ("group")
  #value = name of the value column to create ("relAbun")
    thiscommand <- paste("thiswilcox <- wilcox.test(x, y, paired = TRUE)")
    eval(parse(text = thiscommand))
    tableOfResults[mic, "p_wilcox"] <- thiswilcox$p.value#p value graph
  #paste: multiple elements from the multiple vectors into one element
  #running the wilcox test--looking at y(post berry) - x(pre berry) 
  #parse: to return the parsed but unevaluated expression (text (this command) to be parsed)
    thiscommand <- paste("thiswilcox <- temp %>% wilcox_effsize(relAbun ~ group, paired = TRUE)")
    try(eval(parse(text = thiscommand)))
    tableOfResults[mic, "effect_size"] <- thiswilcox$effsize
  #effect size calculation
}
  tableOfResults <- tableOfResults %>% select(p_wilcox, effect_size)
  #only selecting the p value function and effect size
  return(tableOfResults)
}
```



BRB all levels
```{r warning=FALSE}
spec_dif <- run_wilcox(spec, "rB", "tB")
gen_dif <- run_wilcox(gen, "rB", "tB")
fam_dif <- run_wilcox(fam, "rB", "tB")
ord_dif <- run_wilcox(ord, "rB", "tB")
class_dif <- run_wilcox(class, "rB", "tB")
phyl_dif <- run_wilcox(phyl, "rB", "tB")
king_dif <- run_wilcox(king, "rB", "tB")

#combine and filter to p-value < 0.05
BRBresults <- rbind(class_dif, phyl_dif, king_dif, spec_dif, gen_dif, fam_dif, ord_dif) %>% filter(p_wilcox < 0.05)
#rbind: combining the different levels (rows)
```

```{r}
BRBresults %>% ggplot(aes(x = rownames(BRBresults), y = p_wilcox)) +
  geom_bar(stat = "identity") +
  coord_flip()
# p value plot
```

```{r}
BRBresults %>% ggplot(aes(x = rownames(BRBresults), y = effect_size)) +
  geom_bar(stat = "identity") 
```





